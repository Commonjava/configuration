{"name":"Configuration","tagline":"APIs for Loading Application Configuration Data","body":"### Stretch Out on Our Sectional\r\n\r\nThe Configuration API provides a means of reading single- and multi-section configuration files and injecting their values into Java configuration objects. This allows your application to include add-ons or plugins flexibly, and configure them as part of the main application configuration. Each part of your application will receive its configuration and not have to know anything about any other part.\r\n\r\n### Annotations\r\n\r\n* `@SectionName(\"somepart\")` denotes a configuration class that is responsible for managing the `somepart` section of your application's configuration file.\r\n* `@ConfigName(\"my.email\")` denotes the setter method that should be used to inject the `my.email` configuration field into your configuration class.\r\n* `@ConfigNames({\"field.one\", \"field.two\"}) denotes a constructor in your configuration class which will have two configuration fields (`field.one` and `field.two`) injected as parameters (in order, of course).\r\n\r\n### Simple is Good, Too\r\n\r\nDon't need multiple sections in your configuration? That's okay, too. Simply leave off the `@SectionName` annotation for your configuration class, and the fields in the configuration file without a declared section will be injected. If you want to make sure the configuration reader doesn't even try to load multiple sections, use something like `org.commonjava.web.config.io.SingleSectionConfigReader` to read your config file.\r\n\r\n### `.conf` Goodness\r\n\r\nThe Configuration project also contains a module - `configuration-dotconf` - which knows how to read .ini-style configurations. These are often named `something.conf` in linux, hence the module name. The configuration reader in this module is `org.commonjava.web.config.dotconf.DotConfConfigurationReader`, and it works with files like this:\r\n\r\n```\r\n[main]\r\nport=8080\r\nbind=0.0.0.0\r\n\r\n[auth]\r\nmutual.ssl=enabled\r\n...\r\n```\r\n\r\n### All-Inclusive\r\n\r\nMany management systems like Puppet and Chef work much better when each recipe has an associated file, rather than having multiple recipes that all modify a single file. This is what makes applications like Apache HTTPd simpler to manage; it's use of `/etc/httpd/conf.d` means each virtual host or module activation can have its own file.\r\n\r\nYour application's configuration can be managed in the same way with `org.commonjava.web.config.io.ConfigFileUtils`. Simply add a line like `Include conf.d/*.conf` to your application's configuration, and then use the method `ConfigFileUtils.readFileWithIncludes(File)` to get an `InputStream` that contains the main file's content along with all matching files in the `conf.d/` directory matching the given pattern. The merged contents will replace the original `Include ...` line.\r\n\r\n### Existing Beans, New Beans, Maps and Even Properties Sections\r\n\r\nSometimes it's easier to populate an existing object, other times it's simpler to let the configuration API create the configuration object instances for you. The Configuration API contains section listeners for both cases.\r\n\r\nAnd at other times, you need something more free-form. Sometimes it's just simpler to create a map of options and let your application deal with the flexibility of an arbitrary key-value map for a particular configuration section. Or a Properties instance. Configuration API can handle these cases, too.\r\n\r\nThe Configuration API includes the following section listener implementations:\r\n\r\n* `org.commonjava.web.config.section.BeanSectionListener<T>` - Populate the fields of an existing bean, or creates a new bean from the provided configuration parameters.\r\n* `org.commonjava.web.config.section.MapSectionListener` - Populates a new `java.util.Map` instance from the provided configuration parameters.\r\n* `org.commonjava.web.config.section.PropertiesSectionListener` - Populates a new `java.util.Properties` instance from the provided configuration parameters.\r\n\r\nOr, you can provide your own implementation of `org.commonjava.web.config.section.ConfigurationSectionListener<T>`.\r\n\r\n### Example\r\n\r\nHere's an example that reads a multi-section configuration which can be spread into multiple, included configuration files:\r\n\r\n```\r\npublic class ConfigFactory\r\n    extends DefaultConfigurationListener\r\n{\r\n    private Set<TypedConfigurationSectionListener<?>> sections;\r\n    public ConfigFactory(Set<TypedConfigurationSectionListener<?>> sections){ this.sections = sections; }\r\n\r\n    public void load( final String configPath )\r\n        throws ConfigurationException\r\n    {\r\n        for ( TypedConfigurationSectionListener<?> section : sections )\r\n        {\r\n            with( section.getSectionName(), section.getConfigurationClass() );\r\n        }\r\n\r\n        File configFile = new File( configPath );\r\n        if ( configFile.isDirectory() )\r\n        {\r\n            configFile = new File( configFile, \"main.conf\" );\r\n        }\r\n\r\n        InputStream stream = null;\r\n        try\r\n        {\r\n            stream = ConfigFileUtils.readFileWithIncludes( config );\r\n            new DotConfConfigurationReader( this ).loadConfiguration( stream );\r\n        }\r\n        catch ( final IOException e )\r\n        {\r\n            throw new ConfigurationException( \"Cannot open configuration file: {}. Reason: {}\", e, configPath,\r\n                                              e.getMessage() );\r\n        }\r\n        finally\r\n        {\r\n            closeQuietly( stream );\r\n        }\r\n    }\r\n[...]\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}